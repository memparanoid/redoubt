---
source: crates/redoubt-vault/derive/src/tests/expand.rs
expression: pretty(token_stream)
---
#[derive(RedoubtZero, RedoubtCodec)]
#[fast_zeroize(drop)]
struct Epsilon {
    pub master_seed: [u8; 32],
    pub encryption_key: [u8; 32],
    #[codec(default)]
    __sentinel: ZeroizeOnDropSentinel,
}
use redoubt_vault_core::CipherBoxDyns as _;
impl redoubt_vault_core::CipherBoxDyns<2> for Epsilon {
    fn to_encryptable_dyn_fields(
        &mut self,
    ) -> [&mut dyn redoubt_vault_core::Encryptable; 2] {
        [&mut self.master_seed, &mut self.encryption_key]
    }
    fn to_decryptable_dyn_fields(
        &mut self,
    ) -> [&mut dyn redoubt_vault_core::Decryptable; 2] {
        [&mut self.master_seed, &mut self.encryption_key]
    }
}
impl<A: redoubt_aead::AeadApi> redoubt_vault_core::EncryptStruct<A, 2> for Epsilon {
    fn encrypt_into(
        &mut self,
        aead: &mut A,
        aead_key: &[u8],
        nonces: &mut [Vec<u8>; 2],
        tags: &mut [Vec<u8>; 2],
    ) -> Result<[Vec<u8>; 2], redoubt_vault_core::CipherBoxError> {
        redoubt_vault_core::encrypt_into(
            self.to_encryptable_dyn_fields(),
            aead,
            aead_key,
            nonces,
            tags,
        )
    }
}
impl<A: redoubt_aead::AeadApi> redoubt_vault_core::DecryptStruct<A, 2> for Epsilon {
    fn decrypt_from(
        &mut self,
        aead: &mut A,
        aead_key: &[u8],
        nonces: &mut [Vec<u8>; 2],
        tags: &mut [Vec<u8>; 2],
        ciphertexts: &mut [Vec<u8>; 2],
    ) -> Result<(), redoubt_vault_core::CipherBoxError> {
        redoubt_vault_core::decrypt_from(
            &mut self.to_decryptable_dyn_fields(),
            aead,
            aead_key,
            nonces,
            tags,
            ciphertexts,
        )
    }
}
#[cfg(test)]
#[derive(Debug, Clone, Copy)]
pub enum EpsilonBoxFailureMode {
    None,
    FailOnNthOperation(usize),
}
#[derive(redoubt_zero::RedoubtZero)]
pub struct EpsilonBox {
    inner: redoubt_vault_core::CipherBox<Epsilon, redoubt_aead::Aead, 2>,
    #[cfg(test)]
    failure_counter: usize,
}
impl EpsilonBox {
    #[inline(always)]
    pub fn new() -> Self {
        Self {
            inner: redoubt_vault_core::CipherBox::new(redoubt_aead::Aead::new()),
            #[cfg(test)]
            failure_counter: 0,
        }
    }
    #[inline(always)]
    pub fn open<F, R>(
        &mut self,
        f: F,
    ) -> Result<redoubt_zero::ZeroizingGuard<R>, redoubt_vault_core::CipherBoxError>
    where
        F: FnMut(&Epsilon) -> Result<R, redoubt_vault_core::CipherBoxError>,
        R: Default + redoubt_zero::FastZeroizable + redoubt_zero::ZeroizationProbe,
    {
        #[cfg(test)]
        {
            if self.failure_counter > 0 {
                self.failure_counter -= 1;
                if self.failure_counter == 0 {
                    return Err(
                        redoubt_vault_core::CipherBoxError::IntentionalCipherBoxError
                            .into(),
                    );
                }
            }
        }
        self.inner.open(f)
    }
    #[inline(always)]
    pub fn open_mut<F, R>(
        &mut self,
        f: F,
    ) -> Result<redoubt_zero::ZeroizingGuard<R>, redoubt_vault_core::CipherBoxError>
    where
        F: FnMut(&mut Epsilon) -> Result<R, redoubt_vault_core::CipherBoxError>,
        R: Default + redoubt_zero::FastZeroizable + redoubt_zero::ZeroizationProbe,
    {
        #[cfg(test)]
        {
            if self.failure_counter > 0 {
                self.failure_counter -= 1;
                if self.failure_counter == 0 {
                    return Err(
                        redoubt_vault_core::CipherBoxError::IntentionalCipherBoxError
                            .into(),
                    );
                }
            }
        }
        self.inner.open_mut(f)
    }
    #[cfg(test)]
    pub fn set_failure_mode(&mut self, mode: EpsilonBoxFailureMode) {
        match mode {
            EpsilonBoxFailureMode::None => {
                self.failure_counter = 0;
            }
            EpsilonBoxFailureMode::FailOnNthOperation(n) => {
                self.failure_counter = n;
            }
        }
    }
    #[inline(always)]
    pub fn leak_master_seed(
        &mut self,
    ) -> Result<
        redoubt_zero::ZeroizingGuard<[u8; 32]>,
        redoubt_vault_core::CipherBoxError,
    > {
        #[cfg(test)]
        {
            if self.failure_counter > 0 {
                self.failure_counter -= 1;
                if self.failure_counter == 0 {
                    return Err(
                        redoubt_vault_core::CipherBoxError::IntentionalCipherBoxError
                            .into(),
                    );
                }
            }
        }
        self.inner.leak_field::<[u8; 32], 0, redoubt_vault_core::CipherBoxError>()
    }
    #[inline(always)]
    pub fn leak_encryption_key(
        &mut self,
    ) -> Result<
        redoubt_zero::ZeroizingGuard<[u8; 32]>,
        redoubt_vault_core::CipherBoxError,
    > {
        #[cfg(test)]
        {
            if self.failure_counter > 0 {
                self.failure_counter -= 1;
                if self.failure_counter == 0 {
                    return Err(
                        redoubt_vault_core::CipherBoxError::IntentionalCipherBoxError
                            .into(),
                    );
                }
            }
        }
        self.inner.leak_field::<[u8; 32], 1, redoubt_vault_core::CipherBoxError>()
    }
    #[inline(always)]
    pub fn open_master_seed<F, R>(
        &mut self,
        f: F,
    ) -> Result<redoubt_zero::ZeroizingGuard<R>, redoubt_vault_core::CipherBoxError>
    where
        F: FnMut(&[u8; 32]) -> Result<R, redoubt_vault_core::CipherBoxError>,
        R: Default + redoubt_zero::FastZeroizable + redoubt_zero::ZeroizationProbe,
    {
        #[cfg(test)]
        {
            if self.failure_counter > 0 {
                self.failure_counter -= 1;
                if self.failure_counter == 0 {
                    return Err(
                        redoubt_vault_core::CipherBoxError::IntentionalCipherBoxError
                            .into(),
                    );
                }
            }
        }
        self.inner.open_field::<[u8; 32], 0, F, R, redoubt_vault_core::CipherBoxError>(f)
    }
    #[inline(always)]
    pub fn open_encryption_key<F, R>(
        &mut self,
        f: F,
    ) -> Result<redoubt_zero::ZeroizingGuard<R>, redoubt_vault_core::CipherBoxError>
    where
        F: FnMut(&[u8; 32]) -> Result<R, redoubt_vault_core::CipherBoxError>,
        R: Default + redoubt_zero::FastZeroizable + redoubt_zero::ZeroizationProbe,
    {
        #[cfg(test)]
        {
            if self.failure_counter > 0 {
                self.failure_counter -= 1;
                if self.failure_counter == 0 {
                    return Err(
                        redoubt_vault_core::CipherBoxError::IntentionalCipherBoxError
                            .into(),
                    );
                }
            }
        }
        self.inner.open_field::<[u8; 32], 1, F, R, redoubt_vault_core::CipherBoxError>(f)
    }
    #[inline(always)]
    pub fn open_master_seed_mut<F, R>(
        &mut self,
        f: F,
    ) -> Result<redoubt_zero::ZeroizingGuard<R>, redoubt_vault_core::CipherBoxError>
    where
        F: FnMut(&mut [u8; 32]) -> Result<R, redoubt_vault_core::CipherBoxError>,
        R: Default + redoubt_zero::FastZeroizable + redoubt_zero::ZeroizationProbe,
    {
        #[cfg(test)]
        {
            if self.failure_counter > 0 {
                self.failure_counter -= 1;
                if self.failure_counter == 0 {
                    return Err(
                        redoubt_vault_core::CipherBoxError::IntentionalCipherBoxError
                            .into(),
                    );
                }
            }
        }
        self.inner
            .open_field_mut::<[u8; 32], 0, F, R, redoubt_vault_core::CipherBoxError>(f)
    }
    #[inline(always)]
    pub fn open_encryption_key_mut<F, R>(
        &mut self,
        f: F,
    ) -> Result<redoubt_zero::ZeroizingGuard<R>, redoubt_vault_core::CipherBoxError>
    where
        F: FnMut(&mut [u8; 32]) -> Result<R, redoubt_vault_core::CipherBoxError>,
        R: Default + redoubt_zero::FastZeroizable + redoubt_zero::ZeroizationProbe,
    {
        #[cfg(test)]
        {
            if self.failure_counter > 0 {
                self.failure_counter -= 1;
                if self.failure_counter == 0 {
                    return Err(
                        redoubt_vault_core::CipherBoxError::IntentionalCipherBoxError
                            .into(),
                    );
                }
            }
        }
        self.inner
            .open_field_mut::<[u8; 32], 1, F, R, redoubt_vault_core::CipherBoxError>(f)
    }
}
impl Default for EpsilonBox {
    fn default() -> Self {
        Self::new()
    }
}
