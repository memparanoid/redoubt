// Copyright (c) 2025-2026 Federico Hoerth <memparanoid@gmail.com>
// SPDX-License-Identifier: GPL-3.0-only
// See LICENSE in the repository root for full license text.

---
source: crates/memcode/derive/src/tests/expand.rs
expression: pretty(token_stream)
---
impl<'alpha, Tau> memcode_core::Zeroizable for Sigma<'alpha, Tau>
where
    Tau: memcode_core::MemCode + memcode_core::MemDecode + Clone,
{
    #[inline(always)]
    fn self_zeroize(&mut self) {
        self.zeroize();
    }
}
impl<'alpha, Tau> memcode_core::MemNumElements for Sigma<'alpha, Tau>
where
    Tau: memcode_core::MemCode + memcode_core::MemDecode + Clone,
{
    #[inline(always)]
    fn mem_num_elements(&self) -> usize {
        3
    }
}
impl<'alpha, Tau> memcode_core::MemBytesRequired for Sigma<'alpha, Tau>
where
    Tau: memcode_core::MemCode + memcode_core::MemDecode + Clone,
{
    fn mem_bytes_required(&self) -> Result<usize, memcode_core::OverflowError> {
        let collection: [&dyn memcode_core::MemBytesRequired; 3] = [
            memcode_core::collections::to_bytes_required_dyn_ref(&self.alpha),
            memcode_core::collections::to_bytes_required_dyn_ref(&self.beta),
            memcode_core::collections::to_bytes_required_dyn_ref(&self.gamma),
        ];
        memcode_core::collections::mem_bytes_required(&mut collection.into_iter())
    }
}
impl<'alpha, Tau> memcode_core::MemEncode for Sigma<'alpha, Tau>
where
    Tau: memcode_core::MemCode + memcode_core::MemDecode + Clone,
{
    fn drain_into(
        &mut self,
        buf: &mut memcode_core::MemEncodeBuf,
    ) -> Result<(), memcode_core::MemEncodeError> {
        memcode_core::collections::drain_into(buf, self)
    }
}
impl<'alpha, Tau> memcode_core::MemDecode for Sigma<'alpha, Tau>
where
    Tau: memcode_core::MemCode + memcode_core::MemDecode + Clone,
{
    fn drain_from(
        &mut self,
        bytes: &mut [u8],
    ) -> Result<usize, memcode_core::MemDecodeError> {
        memcode_core::collections::drain_from(bytes, self)
    }
}
impl<'alpha, Tau> memcode_core::DecodeIterator for Sigma<'alpha, Tau>
where
    Tau: memcode_core::MemCode + memcode_core::MemDecode + Clone,
{
    fn decode_iter_mut(
        &mut self,
    ) -> impl Iterator<Item = &mut dyn memcode_core::MemDecodable> {
        let collection: [&mut dyn memcode_core::MemDecodable; 3] = [
            memcode_core::collections::to_decode_dyn_mut(&mut self.alpha),
            memcode_core::collections::to_decode_dyn_mut(&mut self.beta),
            memcode_core::collections::to_decode_dyn_mut(&mut self.gamma),
        ];
        collection.into_iter()
    }
}
impl<'alpha, Tau> memcode_core::EncodeIterator for Sigma<'alpha, Tau>
where
    Tau: memcode_core::MemCode + memcode_core::MemDecode + Clone,
{
    fn encode_iter_mut(
        &mut self,
    ) -> impl Iterator<Item = &mut dyn memcode_core::MemEncodable> {
        let collection: [&mut dyn memcode_core::MemEncodable; 3] = [
            memcode_core::collections::to_encode_dyn_mut(&mut self.alpha),
            memcode_core::collections::to_encode_dyn_mut(&mut self.beta),
            memcode_core::collections::to_encode_dyn_mut(&mut self.gamma),
        ];
        collection.into_iter()
    }
}
impl<'alpha, Tau> memcode_core::MemEncodable for Sigma<'alpha, Tau>
where
    Tau: memcode_core::MemCode + memcode_core::MemDecode + Clone,
{}
impl<'alpha, Tau> memcode_core::MemDecodable for Sigma<'alpha, Tau>
where
    Tau: memcode_core::MemCode + memcode_core::MemDecode + Clone,
{}
impl<'alpha, Tau> memcode_core::CollectionEncode for Sigma<'alpha, Tau>
where
    Tau: memcode_core::MemCode + memcode_core::MemDecode + Clone,
{}
impl<'alpha, Tau> memcode_core::CollectionDecode for Sigma<'alpha, Tau>
where
    Tau: memcode_core::MemCode + memcode_core::MemDecode + Clone,
{
    fn prepare_with_num_elements(
        &mut self,
        size: usize,
    ) -> Result<(), memcode_core::MemDecodeError> {
        memcode_core::collections::mem_decode_assert_num_elements(3, size)
    }
}
